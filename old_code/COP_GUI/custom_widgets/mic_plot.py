# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mic_plot.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import matplotlib
matplotlib.use('Qt5Agg')
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker
import queue
import numpy as np
import sounddevice as sd

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtMultimedia import QAudioDeviceInfo, QAudio, QCameraInfo

input_audio_deviceInfos = QAudioDeviceInfo.availableDevices(QAudio.AudioInput)

class MplCanvas(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = fig.add_subplot(111)
        super(MplCanvas, self).__init__(fig)
        fig.tight_layout()

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(260, 255)
        self.gridLayout_2 = QtWidgets.QGridLayout(Form)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.mic_plot_start = QtWidgets.QPushButton(Form)
        self.mic_plot_start.setObjectName("mic_plot_start")
        self.gridLayout_2.addWidget(self.mic_plot_start, 1, 0, 1, 1)
        self.mic_plot_stop = QtWidgets.QPushButton(Form)
        self.mic_plot_stop.setObjectName("mic_plot_stop")
        self.gridLayout_2.addWidget(self.mic_plot_stop, 1, 1, 1, 1)

        #self.widget = QtWidgets.QWidget(Form)
        #self.widget.setStyleSheet("background-color: rgb(0, 0, 0);")
        #self.widget.setObjectName("widget")
        #self.gridLayout_2.addWidget(self.widget, 2, 0, 1, 2)

        #That widget was there to mark our place in the grid. We will manually add an MPL canvas there instead.

        self.canvas = MplCanvas(self,)

        self.mic_plot_combo_box = QtWidgets.QComboBox(Form)
        self.mic_plot_combo_box.setObjectName("mic_plot_combo_box")
        self.gridLayout_2.addWidget(self.mic_plot_combo_box, 0, 1, 1, 1)
        self.label = QtWidgets.QLabel(Form)
        self.label.setObjectName("label")
        self.gridLayout_2.addWidget(self.label, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

        self.threadpool = QtCore.QThreadPool()
        self.devices_list= []
        for device in input_audio_deviceInfos:
            self.devices_list.append(device.deviceName())

        self.mic_plot_combo_box.addItems(self.devices_list)
        self.mic_plot_combo_box.currentIndexChanged['QString'].connect(self.update_now)
        self.mic_plot_combo_box.setCurrentIndex(0)

        self.canvas = MplCanvas(self, width=5, height=4, dpi=100)
        self.gridLayout_2.addWidget(self.canvas, 2, 0, 1, 2)
        self.reference_plot = None
        self.q = queue.Queue(maxsize=20)

        self.device = 0
        self.window_length = 1000
        self.downsample = 1
        self.channels = [1]
        self.interval = 30

        device_info = sd.query_devices(self.device, 'input')
        self.samplerate = device_info['default_samplerate']
        length = int(self.window_length*self.samplerate/(1000*self.downsample))
        sd.default.samplerate = self.samplerate

        self.plotdata = np.zeros((length, len(self.channels)))

        self.update_plot()
        self.timer = QtCore.QTimer()
        self.timer.setInterval(self.interval)
        self.timer.timeout.connect(self.update_plot)
        self.timer.start()
        self.mic_plot_start.clicked.connect(self.start_worker)
        self.mic_plot_stop.clicked.connect(lambda:self.close())


        self.show()

    def getAudio(self):
        try:
            def audio_callback(indata,frames,time,status):
                self.q.put(indata[::self.downsample,[0]])
            stream  = sd.InputStream( device = self.device, channels = max(self.channels), samplerate =self.samplerate, callback  = audio_callback)
            with stream:
                input()
        except Exception as e:
            print("ERROR: ",e)

    def start_worker(self):
        worker = Worker(self.start_stream, )
        self.threadpool.start(worker)

    def start_stream(self):
        self.mic_plot_combo_box.setEnabled(False)
        self.mic_plot_start.setEnabled(False)
        self.getAudio()

    def update_now(self,value):
        self.device = self.devices_list.index(value)
        print('Device:',self.devices_list.index(value))

    def update_window_length(self,value):
        self.window_length = int(value)
        length  = int(self.window_length*self.samplerate/(1000*self.downsample))
        self.plotdata =  np.zeros((length,len(self.channels)))
        self.update_plot()

    def update_sample_rate(self,value):
        self.samplerate = int(value)
        sd.default.samplerate = self.samplerate
        length  = int(self.window_length*self.samplerate/(1000*self.downsample))
        self.plotdata =  np.zeros((length,len(self.channels)))
        self.update_plot()

    def update_down_sample(self,value):
        self.downsample = int(value)
        length  = int(self.window_length*self.samplerate/(1000*self.downsample))
        self.plotdata =  np.zeros((length,len(self.channels)))
        self.update_plot()
    def update_interval(self,value):
        self.interval = int(value)
        self.timer.setInterval(self.interval) #msec
        self.timer.timeout.connect(self.update_plot)
        self.timer.start()

    def update_plot(self):
        try:
            data=[0]

            while True:
                try:
                    data = self.q.get_nowait()
                except queue.Empty:
                    break
                shift = len(data)
                self.plotdata = np.roll(self.plotdata, -shift,axis = 0)
                self.plotdata[-shift:,:] = data
                self.ydata = self.plotdata[:]
                self.canvas.axes.set_facecolor((0,0,0))

                if self.reference_plot is None:
                    plot_refs = self.canvas.axes.plot( self.ydata, color=(0,1,0.29))
                    self.reference_plot = plot_refs[0]
                else:
                    self.reference_plot.set_ydata(self.ydata)
            self.canvas.axes.yaxis.grid(True,linestyle='--')
            start, end = self.canvas.axes.get_ylim()
            self.canvas.axes.yaxis.set_ticks(np.arange(start, end, 0.1))
            self.canvas.axes.yaxis.set_major_formatter(ticker.FormatStrFormatter('%0.1f'))
            self.canvas.axes.set_ylim( ymin=-0.5, ymax=0.5)
            self.canvas.draw()
        except:
            pass

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.mic_plot_start.setText(_translate("Form", "Start"))
        self.mic_plot_stop.setText(_translate("Form", "Stop"))
        self.label.setText(_translate("Form", "Choose Device:"))

class Worker(QtCore.QRunnable):
    def __init__(self, function, *args, **kwargs):
        super(Worker, self).__init__()
        self.function = function
        self.args = args
        self.kwargs = kwargs

    @pyqtSlot()
    def run(self):
        self.function(*self.args, **self.kwargs)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Form = QtWidgets.QWidget()
    ui = Ui_Form()
    ui.setupUi(Form)
    Form.show()
    sys.exit(app.exec_())
